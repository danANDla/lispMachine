# Лабораторная работа №3 по Архитектуре компьютера.
- Алексеев Даниил, Р33302
- ```lisp | acc | harv | hw | instr | struct | stream | port | prob2```



# Язык программирования Lisp
S-expression - символьноe выражение - способ представления вложенных списков данныx.
``` ebnf
program ::= s-expression
s_expression ::= atomic_symbol \
               / list 
list ::= "(" s_expression < s_expression > ")"
atomic_symbol ::= letter atom_part
atom_part ::= empty / letter atom_part / number atom_part
letter ::= "a" / "b" / " ..." / "z"
number ::= "1" / "2" / " ..." / "9"
empty ::= " "
```

Эапы трансляции:
text → [reader] → [evaluator] → opcodes

## [reader]

На вход принимает принимает текст и возвращает s-expressions.

**базовые элементы s-expression**

1. **lists** - помещаются в скобки, могут содержать любое количество элементов разделенных пробельными символами. Элементы являются s-expression’ами, т.е. lists содержут atoms или lists.
2. **atoms -** все остальное.
    - numbers
    - strings
    - names: функции, переменные, операторы.

## [evaluator]

На вход принимаются lisp forms и формируется машинный код. Не все s-expression являются lisp-forms. Lisp form - всё, что должно быть вычислено (evalueted). Можно сказать, что ***Вычислитель (evaluator)*** это функция (в общем значении), которая на вход получает правильную Lisp form и возвращает некоторое значение.d

**Lisp forms могут быть:**

- atoms
    - symbols: переменные
    - self-evaluating objects: numbers, strings. константы **`T`**, **`NIL`** - канонические значения true и false. **`NIL`** также обозначает пустой список: если ***reader*** видит `()` то интерпретирует это как **`NIL`**. **`NIL`** в - единственный объект одновременно являющийся атом и списком.
- lists
    - functions. Вычисляет все элементы списка и подает их на вход именованной функции (первому элементу списка).
    - special forms/special operators. Не все операции могут быть определены как функции. В эту категорюю попадают конструкии, контролирующие выполнение программы (control structs)
    - macros. Конструкции расширяющие основной синтаксис Lisp. Макросы это функции которые получают s-expression в качестве аргументы и возвращают Lisp form, которая затем вычисляется вместо макроса. определяется при помощи конструкции **`(defmacro macrosName (parametersL))`**
        1. элементы макроса пробрасываются в функцию без вычисления
        2. Lisp form, возвращаемая макросом вычисляется согласно обычным правилам

**функции**

**`print`** - вывести значение переменной
**`scan`** - считать значение переменной

**функции-операторы (в общем значении) тоже являются функциями**

- арифметические
    - **`+`**
    - **`-`**
    - **`mod`**, **`rem`**
- сравнения (только числа? можно только числа, пожалуйста)
    - **`> ≥`**
    - **`=`**

**special operators (standard control structs)**

**`progn`** позволяет вычислить несколько форм, возвращает значение последней формы

**`setq`** выражение присвоения. присваевет значение формы именованной переменной

**`if`**  в качестве условия принимается форма, если он вычисляема и ее значение не **`NIL`** , то вычисляется then-form, в противном случае else-form. с использованием макросов можно создать оператор **`when`**, который позволяет использовать вычислять несколько форм в случае true или false.

**`loop`** - цикл, работает пока не достигнут **`return`** (в реальности loop является макросом и реализован довольно [сложно](https://sourceforge.net/p/clisp/clisp/ci/default/tree/src/loop.lisp))

# ISA (instruction set architechture)

аккумуляторная архитектура - значит **все операции - однооперандные -** всегда применяются к значению в аккумуляторе и еще какому-то значение (хард код или память)


| OPCODE | ARG | DESCRIPTION | ADDRESSING |
| --- | --- | --- | --- |
| load | imm / mem | загрузить данные в аккумулятор | 1/2 |
| store | imm | загрузить данные из аккумулятора в память по адресу из аргумента | |
| add | imm / mem  | сложить аккумулятор с числом или числом из памяти | 1 |
| sub | imm / mem  | вычесть из аккумулятора с число или число из памяти | 1 |
| mod | |  | 1 |
| rem | |  | 1 |
| print | | загрузить данные из аккумулятора в порт io |  |
| read | mem | считать из io в аккумулятор | 1 | 
| jmp | imm | безусловный переход, изменить PC на значение из аккумулятора | 1/3 |
| cmp | imm / mem | сравнить аккумулятор с чсилом или значением из памяти | 1 |
| je | imm | елси ZF == 1, произвести переход по значению из аккумулятора | 1/3 |
| jne | imm | елси ZF == 0, произвести переход по значению из аккумулятора | 1/3 |
| jl | imm | елси SF == 1 && ZF == 0, произвести переход по значению из аккумулятора | 1/3 |
| jle | imm | елси SF == 1 \|\| ZF == 1, произвести переход по значению из аккумулятора | 1/3 |
| hlt | | остановка | |

ADDRESSING - режимы адресации: 1 - прямая, 2 - косвенная, 3 - относительная прямая
