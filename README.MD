# Lisp

text → [reader] → [evaluator] → opcodes

[https://courses.cs.northwestern.edu/325/readings/interpreter.php](https://courses.cs.northwestern.edu/325/readings/interpreter.php)

[https://gigamonkeys.com/book/syntax-and-semantics.html](https://gigamonkeys.com/book/syntax-and-semantics.html)

## [reader]

На вход принимает принимает текст и возвращает s-expressions

синтаксис состоит из s-expression’ов

s-expression - символьно выражение - способ представления вложенных списков данных

**базовые элементы s-expression**

1. **lists** - помещаются в скобки, могут содержать любое количество элементов разделенных пробельными символами. Элементами являются s-expression’ами, т.е. lists сожержут atoms или lists.
2. **atoms -** все остальное.
    - numbers
    - strings
    - names: функции, переменные, операторы.

## [evaluator]

На вход принимаются lisp forms и формируется машинный код. Не все s-expression являются lisp-forms. Lisp form - всё, что должно быть вычислено (evalueted). Можно сказать, что ***Вычислитель (evaluator)*** это функция (в общем значении), которая на вход получает правильную Lisp form и возвращает некоторое значение.d

**Lisp forms могут быть:**

- atoms
    - symbols: переменные
    - self-evaluating objects: numbers, strings. константы **`T`**, **`NIL`** - канонические значения true и false. **`NIL`** также обозначает пустой список: если ***reader*** видит `()` то интерпретирует это как **`NIL`**. **`NIL`** в - единственный объект одновременно являющийся атом и списком.
- lists
    - functions. Вычисляет все элементы списка и подает их на вход именованной функции (первому элементу списка).
    - special forms/special operators. Не все операции могут быть определены как функции. В эту категорюю попадают конструкии, контролирующие выполнение программы (control structs)
    - macros. Конструкции расширяющие основной синтаксис Lisp. Макросы это функции которые получают s-expression в качестве аргументы и возвращают Lisp form, которая затем вычисляется вместо макроса. определяется при помощи конструкции **`(defmacro macrosName (parametersL))`**
        1. элементы макроса пробрасываются в функцию без вычисления
        2. Lisp form, возвращаемая макросом вычисляется согласно обычным правилам

**функции**

**`setq`** - присвоить значение переменной

**`print`** - вывести значение переменной

**функции-операторы (в общем значении) тоже являются функциями**

- арифметические
    - **`+`**
    - **`-`**
    - **`mod`**, **`rem`**
- сравнения (только числа? можно только числа, пожалуйста)
    - **`> ≥`**
    - **`< ≤`**
    - **`=`**

**special operators (standard control structs)**

**`progn`** позволяет вычислить несколько форм, возвращает значение одной формы

**`setq`** выражение присвоения. присваевет значение формы именованной переменной

**`if`**  в качестве условия принимается форма, если он вычисляема и ее значение не **`NIL`** , то вычисляется then-form, в противном случае else-form. с использованием макросов можно создать оператор **`when`**, который позволяет использовать вычислять несколько форм в случае true или false.

**`loop`** - цикл, работает пока не достигнут **`return`** (в реальности loop является макросом и реализован довольно [сложно](https://sourceforge.net/p/clisp/clisp/ci/default/tree/src/loop.lisp))

# ISA (instruction set architechture)

аккумуляторная архитектура - значит **все операции - однооперандные -** всегда применяются к значению в аккумуляторе и еще какому-то значение (хард код или память)


| OPCODE | DESCRIPTION |
| --- | --- |
| load imm[8\|16\|32] / Mem[8\|16\|32] | загрузить данные в аккумулятор |
| store imm[8\|16\|32] / Mem[8\|16\|32] | загрузить данные из аккумулятора в память |
| add imm[8\|16\|32] / Mem[8\|16\|32]  | сложить аккумулятор с числом или числом из памяти |
| sub imm[8\|16\|32] / Mem[8\|16\|32]  | вычесть из аккумулятора с число или число из памяти |
| mod |  |
| rem |  |
| print | загрузить данные из аккумулятора в порт io |
| read | считать из io в аккумулятор |
| jmp | безусловный переход, изменить PC на значение из аккумулятора |
| cmp imm[8\|16\|32] / Mem[8\|16\|32] | сравнить аккумулятор с чсилом или значением из памяти |
| je  | елси ZF = 1, произвести переход по значению из аккумулятора |
| hlt | остановка |
